protocol USDTLikeToken {
  version: "1.0.0";
  owner: "doge1owner...";

  state {
    name: string = "Tether USD";
    symbol: string = "USDT";
    decimals: int = 6;

    total_supply: int = 0;
    max_supply: int = 1000000000;
    owner_addr: address = "doge1owner...";

    balances_placeholder: string = "";

    paused: bool = false;

    basis_points_rate: int = 0;
    maximum_fee: int = 0;
    _fee: int = 0;
    _send: int = 0;
    max_tx_amount: int = 500000;
    frozen_placeholder: string = "";
    _result: string = "ok";
  }

  method set_fee_policy(bps, cap) { state.basis_points_rate = params.bps; state.maximum_fee = params.cap }
  returns: string "ok";

  method issue(amount) {
    state._result = "ok";
    if (params.amount <= 0) { state._result = "InvalidAmount" }
    if (state.total_supply + params.amount > state.max_supply) { state._result = "ExceedsMaxSupply" }
    if (state._result == "ok") { state.total_supply = state.total_supply + params.amount }
    if (state._result == "ok") { state.balances[state.owner_addr] = state.balances[state.owner_addr] + params.amount }
    if (state._result == "ok") { emit Issue(state.owner_addr, params.amount, state.total_supply) }
  }
  returns: string state._result;

  method balance_of(user) { state.total_supply = state.total_supply }
  returns: int state.balances[params.user];

  method pause() { state.paused = "true" }
  returns: string "paused";

  method unpause() { state.paused = "false" }
  returns: string "unpaused";

  method calc_fee(amount) { state.total_supply = state.total_supply }
  returns: int (params.amount * state.basis_points_rate) / 10000;

  method freeze(user) { state.frozen[params.user] = "true" }
  returns: string "ok";

  method unfreeze(user) { state.frozen[params.user] = "false" }
  returns: string "ok";

  method transfer(to, amount) {
    state._result = "ok";
    if (params.amount <= 0) { state._result = "InvalidAmount" }
    if (state.paused == "true") { state._result = "Paused" }
    if (params.amount > state.max_tx_amount) { state._result = "ExceedsLimit" }
    if (state.frozen[ctx.sender] == "true") { state._result = "SenderFrozen" }
    if (state.frozen[params.to] == "true") { state._result = "RecipientFrozen" }
    if (state.balances[ctx.sender] < params.amount) { state._result = "Insufficient" }

    if (state._result == "ok") { state._fee = params.amount }
    if (state._result == "ok") { state._fee = state._fee * state.basis_points_rate }
    if (state._result == "ok") { state._fee = state._fee / 10000 }
    if (state._result == "ok") { if (state._fee > state.maximum_fee) { state._fee = state.maximum_fee } }
    if (state._result == "ok") { state._send = params.amount - state._fee }
    if (state._result == "ok") { state.balances[ctx.sender] = state.balances[ctx.sender] - params.amount }
    if (state._result == "ok") { state.balances[params.to] = state.balances[params.to] + state._send }
    if (state._result == "ok") { state.balances[state.owner_addr] = state.balances[state.owner_addr] + state._fee }
    if (state._result == "ok") { emit Transfer(ctx.sender, params.to, state._send, state._fee) }
  }
  returns: string state._result;
}
protocol USDTLikeToken {
  version: "1.0.0";
  owner: "doge1owner...";

  state {
    name: string = "Tether USD";
    symbol: string = "USDT";
    decimals: int = 6;

    total_supply: int = 0;
    max_supply: int = 1000000000;
    owner_addr: address = "doge1owner...";

    balances_placeholder: string = "";

    paused: bool = false;

    basis_points_rate: int = 0;
    maximum_fee: int = 0;
    _fee: int = 0;
    _send: int = 0;
    max_tx_amount: int = 500000;
    frozen_placeholder: string = "";
    _result: string = "ok";
  }

  method set_fee_policy(bps, cap) { state.basis_points_rate = params.bps; state.maximum_fee = params.cap }
  returns: string "ok";

  method issue(amount) {
    state._result = "ok"
    if (params.amount <= 0) { state._result = "InvalidAmount" }
    if (state.total_supply + params.amount > state.max_supply) { state._result = "ExceedsMaxSupply" }
    if (state._result == "ok") { state.total_supply = state.total_supply + params.amount }
    if (state._result == "ok") { state.balances[state.owner_addr] = state.balances[state.owner_addr] + params.amount }
    if (state._result == "ok") { emit Issue(state.owner_addr, params.amount, state.total_supply) }
  }
  returns: string state._result;

  method balance_of(user) { state.total_supply = state.total_supply }
  returns: int state.balances[params.user];

  method pause() { state.paused = "true" }
  returns: string "paused";

  method unpause() { state.paused = "false" }
  returns: string "unpaused";

  method calc_fee(amount) { state.total_supply = state.total_supply }
  returns: int (params.amount * state.basis_points_rate) / 10000;

  method freeze(user) { state.frozen[params.user] = "true" }
  returns: string "ok";

  method unfreeze(user) { state.frozen[params.user] = "false" }
  returns: string "ok";

  method transfer(to, amount) {
    state._result = "ok"
    if (params.amount <= 0) { state._result = "InvalidAmount" }
    if (state.paused == "true") { state._result = "Paused" }
    if (params.amount > state.max_tx_amount) { state._result = "ExceedsLimit" }
    if (state.frozen[ctx.sender] == "true") { state._result = "SenderFrozen" }
    if (state.frozen[params.to] == "true") { state._result = "RecipientFrozen" }
    if (state.balances[ctx.sender] < params.amount) { state._result = "Insufficient" }

    // 计算费用与划转（仅当 _result == ok）
    if (state._result == "ok") { state._fee = params.amount }
    if (state._result == "ok") { state._fee = state._fee * state.basis_points_rate }
    if (state._result == "ok") { state._fee = state._fee / 10000 }
    if (state._result == "ok" && state._fee > state.maximum_fee) { state._fee = state.maximum_fee }
    if (state._result == "ok") { state._send = params.amount - state._fee }
    if (state._result == "ok") { state.balances[ctx.sender] = state.balances[ctx.sender] - params.amount }
    if (state._result == "ok") { state.balances[params.to] = state.balances[params.to] + state._send }
    if (state._result == "ok") { state.balances[state.owner_addr] = state.balances[state.owner_addr] + state._fee }
    if (state._result == "ok") { emit Transfer(ctx.sender, params.to, state._send, state._fee) }
  }
  returns: string state._result;
}


  